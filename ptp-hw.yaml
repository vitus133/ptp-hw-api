openapi: 3.0.3
info:
  title: Clock Chain Configuration Schema
  description: OpenAPI specification for clock chain configuration
  version: 1.0.1

components:
  schemas:
    ClockChain:
      type: object
      required:
        - structure
      properties:
        commonDefinitions:
          description: |
            this section includes definitions applied to multiple entities within the chain, such as ESync
            they can be referenced in the relevant entities by name, to avoid multiple copies
          type: object
          properties:
            refSyncDefinitions:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                  relatedPinBoardLabel:
                    type: string
            eSyncDefinitions:
              type: array
              items:
                type: object
                properties:
                  name:
                    type: string
                  esyncConfig:
                    $ref: '#/components/schemas/ESyncConfig'
        structure:
          description: defines the system structure as a list of atomic synchronization subsystems
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/Subsystem'

        behavior:
          type: object
          description: |
            Defines the system behavior based on synchronization sources, conditions and associated actions. The conditions for 
            the sources can be "default", "init", "locked" or "hold". 
            The "default" condition initializes the hardware in each subsystem to the manufacturer recommended defaults for the 
            automatic mode. The "init" condition initializes the hardware in each subsystem to allow the "Acquiring" state (for example
            disable GNSS in the boundary clock setups). 
            Bidirectional links between different subsystems can remain disconnected, as the desired link
            direction is still unknown.
            The "locked" condition in one of the subsystems will configure the bidirectional links to be disciplined by the 
            locked subsystem. If more than one subsystem is locked, the source with the smaller index will have higher priority.
            If the active source is lost, and no other sources are "locked", the subsystem of the last active source may enter holdover
            (subject to the daemon holdover decision). Other subsystems will be connected to follow the DPLL in holdover
          properties:
            sources:
              type: array
              items:
                $ref: '#/components/schemas/SourceConfig'
              description: |
                Sources of frequency, phase and time reference. Sources are identified by clock ID and pin board label,
                tying them to the specific subsystem entity. Sources are characterized by type and can be referenced 
                system-wide by the name
            conditions:
              type: array
              items:
                $ref: '#/components/schemas/Condition'

    Condition:
      type: object
      required:
        - name
        - sources
        - desiredStates
      properties:
        name:
          type: string
          description: Human-readable condition name
        sources:
          type: array
          minItems: 1
          items:
            type: object
            required:
              - sourceName
              - conditionType
            properties:
              sourceName:
                type: string
                description: Name of the source being evaluated
              conditionType:
                type: string
                enum: ["default", "init", "locked", "lost"]
                description: The state condition of the source
          description: |
            Array of source conditions that must ALL be true (implicit AND operation).
            The first condition in the array is the Triggering Condition, while all otherrs are Supporting Conditions (that must be true for 
            the desired states to be applied). For example, if two different subsystems have two different sources, there is still only
            one subsystem that will activate holdover if all other sources are lost.

        desiredStates:
          type: array
          items:
            $ref: '#/components/schemas/DesiredState'
          description: A list of pin and connector settings that together define the desired state. The configurations 
          are applied (in the order they are listed) when the condition is triggered.
      description: Condition that evaluates an array of sources with implicit AND logic between them
            
    DesiredState:
      type: object
      properties:
        clockId:
          type: string
          description: Subsystem clock ID.
          pattern: '(?:(0[xX][0-9a-fA-F]+)|([0-9]))'
          example: "5799633565432596414 or 0xaabbccfffeddeeff"
        boardLabel:
          type: string
          description: |
            Board label and clock ID together unambiguously identify the subsystem and the DPLL pin, together with an optional external
            connector, if defined.
            If the pin is routed through an external connector, the connector settings (direction, frequency, etc.) are derived from the pin configuration
        eec:
          $ref: '#/components/schemas/PinState'
        pps:
          $ref: '#/components/schemas/PinState'        
            
    PinState:
      type: object
      description: |
        Pin desired state.
        Input pins are controlled through priority.
        Output pins are controlled through state.
        Connectors, if referenced in pin config, are automatically set to the same state and frequency as the pin.
      properties:
        priority:
          type: number
          description: Pin input priority (for input pins only)
        state:
          type: string
          enum: ["connected", "disconnected", "selectable"]
          description: Pin desired state 
      
    SourceConfig:
      type: object
      properties:
        name: 
          type: string
          description: source name (must be unique system-wide)
        clockId:
          type: string
          description: Subsystem clock ID.
          pattern: '(?:(0[xX][0-9a-fA-F]+)|([0-9]))'
          example: "5799633565432596414 or 0xaabbccfffeddeeff"
        sourceType:
          type: string
          enum: ["ptpTimeReceiver", "gnss"]
          description: |
            Identifies the source type. If sourceType is ptpTimeReceiver, ptpTimeReceivers must be specified.
            In all cases, boardLabel must be specified.
        boardLabel:
          type: string
          description: |
            Board label and clock ID together unambiguously identify the subsystem and the DPLL pin receiving the source
        ptpTimeReceivers:
          type: array
          description: ports configured to act as PTP time receivers (if the sourceType is set to 'ptpTimeReceiver')         
          items:
            type: string
            pattern: '^[a-zA-Z0-9_-]+$'
 
    Subsystem:
      type: object
      description: defines an atomic synchronization subsystem of a single DPLL and one or more Ethernet subsystems linked together
      required:
        - dpll
        - name
      properties:
        name:
          type: string
        dpll:
          $ref: '#/components/schemas/Dpll'
        ethernet:
          type: array
          minItems: 1
          items:
            $ref: '#/components/schemas/Ethernet'
     
    Dpll:
      type: object
      description: |
        Generic DPLL configuration within a synchronization subsystem.
        Configuration of this section will result in DPLL device configurations through the Netlink driver.
      properties:
        clockId:
          type: string
          description: Optional clock ID. If omitted, the hardware must support clock ID discovery.
          pattern: '(?:(0[xX][0-9a-fA-F]+)|([0-9]))'
          example: "5799633565432596414 or 0xaabbccfffeddeeff"
        phaseInputs:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/PinConfig'
          description: Phase reference input pins, keyed by board label   
        phaseOutputs:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/PinConfig'
          description: Optional phase output pins, keyed by board label        
        frequencyOutputs:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/PinConfig'
          description: Optional frequency outputs for other devices or measurements, keyed by board label
        frequencyInputs:
          type: object
          additionalProperties:
            $ref: '#/components/schemas/PinConfig'
          description: Optional frequency reference inputs, keyed by board label
    Ethernet:
      type: object
      description: |
        Defines the Ethernet subsystem and unambiguously identifies ethernet ports belonging
        to it. This may be required to support various port naming schemes.
      required:
        - ports
      properties:
        ports:
          type: array
          items:
            type: string
          description: |
            A list of Ethernet port names associated with this Ethernet subsystem. The default
            port, or the port used to address the network adapter configuration through sysfs, is listed first.
    PinConfig:
      type: object
      properties:
        connector:
          type: string
          description: |
            Connector identifier on the device (e.g., "SMA1", "U.FL2"), Optional. 
            Defines the physical connector this pin is statically or dynamically routed to.
            Used by the hardware plugin software to configure connector logic, if present 
          pattern: '^[a-zA-Z0-9_-]+$'
          example: "SMA1"
        
        phaseAdjustment:
          $ref: '#/components/schemas/PhaseAdjustment'
          description: Optional phase adjustment in picoseconds
        
        frequency:
          type: number
          minimum: 0
          default: 1
          description: Frequency value in Hz (for frequency pins) or phase reference frequency (for phase pins, defaults to 1 PPS)
          example: 10000000
        
        syncTechnologyConfigName:
          type: string
          description: Optional eSync or ref-sync configuration name (defined in CommonDefinitions)
          
        description:
          type: string
          description: Optional description for this pin configuration
      description: |
        Pin configuration for DPLL phase or frequency signals in a dictionary format 
        (boardLabel is the key). 
        The frequency and eSync should not be configured together.

    ESyncConfig:
      type: object
      required:
        - transferFrequency
      properties:
        transferFrequency:
          type: number
          description: Configurable transfer frequency in Hz.
          example: 10000000
        embeddedSyncFrequency:
          type: number
          default: 1
          description: Embedded sync frequency in Hz. If omitted, set to 1Hz (1PPS)
        dutyCyclePct:
          type: number
          default: 25
          description: The phase signal pulse duty cycle in percent. If omitted, set to 25%
      description: eSync feature configuration

    PhaseAdjustment:
      type: object
      required:
        - internal
      properties:
        internal:
          type: integer
          description: |
            Internal phase adjustment in picoseconds. Usually compensates for the board hardware delays and should not be changed by user
          example: 100
        external:
          type: integer
          description: External phase adjustment in picoseconds. Compensates for delays introduced by external cables
          example: 50
      description: |
        Phase adjustment that must be applied to the input or the output pin to compensate for phase delays from routing,
        logic and cables.
        Usually internal delay is applied to output pins, and the sum of internal and external delays is applied to input pins. Sometimes 
        the above adjustment is not possible (E.g. if the input side is not programmable). In this case external delays will be 
        summed with the internal delays and applied to the output side.
    
